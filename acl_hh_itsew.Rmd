---
title: "ACL_HH_ITSEW"
author: "Aulia Dini Rafsanjani"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=FALSE, warning=FALSE}
#library
library(tidyverse)
library(lme4)
library(mi)
library(knitr)
library(tidyr)
library(survey)
library(ggpubr)
library(car)
library(reshape2)
library(glmnet)
library(fastDummies)
library(corrplot)
library(forcats)
library(dplyr)
library(ggplot2)
library(readxl)
library(tidycensus)
library(nlme)
library(srvyr)
library(weights)
library(anesrake)
library(magrittr)
library(mice)
library(nnet)
library(broom)
library(kableExtra)
library(nnet)
library(jpeg)
library(pROC)
library(gtsummary)
library(forcats)
library(flextable)

# count missing category
count_missing_categorical <- function(column) {
  na_count <- sum(is.na(column))
  empty_count <- sum(column == "" | column == "NA" | column == "N/A") 
  
  if (is.na(na_count)) {
    return(empty_count)
  } else if (is.na(empty_count)) {
    return(na_count)
  }
  
  return(na_count + empty_count)
}
```

### Subset data for modelling

```{r}
#open acl data
acl_data <- read.csv("O:/ACL Data Management/wave6/_acl123456_newest/acl123456_2024_03_22.csv")
```

```{r}
#open acl data
#acl_data <- read.csv("O:/ACL Data Management/wave6/_acl123456_newest/_to outside teams/_aulia thesis/acl123456_2024_01_09_getis.csv")
```

```{r}
#subset variables
acl_sub <- acl_data[, c("ï..V1", "V2", "V22009", "V2004",
                        "V15102", "V20102",
                        "V12021", "V15101", "V20101",
                        "V13113", "V17110", "V21791",
                        "V12968", "V16902", "V22101"
                        )]
```

Note:

V22009 6-wave panel participation pattern w/ death status (2021-01-08) info/1=W5 Slf-Rep/2=W5 Proxy/3=W5 Non-Respondent/4=W5 Dead

V2004 RR3:RESPONDENT RACE (1968)

V15102 W5.AAGE_A_1.Age of FIRST Adult in HH (Respondent) 

V20102 W6.AAGE_A_1.Age of first adult in HH (respondent) 

V12021 W4.A_1d(1).Sex of FIRST Adult in HH 

V15101 W5.ASEX_A_1.Sex of FIRST Adult in HH (Respondent)

V20101 W6.ASEX_A_1.Sex of first adult in HH (respondent)

V13113 W4.R & Spouse Income.Cleaned and Imputed 

V17110 W5.Continuous R and Spouse Income.Final. Cleaned and Imputed.

V21791 W6.Continuous R and Spouse Income.Final. Cleaned and Imputed.

V12962 W4.Revised Re-Centered Wave 4 Cross-Section Weight.(Revision: drops 2 W4 Wrong-Person Iw cases and then Re-centers Weight Values).W1 & W4 Respondents only.CENTERED

V12968. W4.Revised Re-Centered Wave 4 Panel Weight.(Revision: drop one W4 Wrong-Person Iw case and then Re-centers Weight Values).W1, W2, W3 & W4 Respondents only.CENTERED 

V16902. W5.(Weight55).5-Wave Panel Weight.Centered

V22101 W6.(Weight61).Cross-Section Weight.Centered

```{r}
# change the column names
colnames(acl_sub) <- c("V1", "V2", "response", "race_1968",
                       "age_2011", "age_2019",
                       "sex_2001", "sex_2011", "sex_2019", 
                       "income_2001", "income_2011", "income_2019",
                       "weight_2001", "weight_2011", "cross_weight_2019")
```

### Region data

```{r}
acl_region <- read.csv("O:/ACL Data Management/wave6/_acl123456_newest/_to outside teams/_aulia thesis/acl123456_restricted_participant state of residence.csv")
```

```{r}
# subset region for wave 4 and 5 only
reg_sub <- acl_region[,c("ï..V1", "V22228", "V22233")]
```

Note:

V22228 long_w4_STATEFP10.Wave 4 Longitudinal State FIP ID (2010)

V22233 long_w5_STATEFP10.Wave 5 Longitudinal State FIP ID (2010)

```{r}
#  change the column names
colnames(reg_sub) <- c("V1", "state_2001", "state_2011")
```

```{r}
#test1 <- subset(acl_region, V22233=="72")
```

### State recode

```{r}
# Function to map region codes to corresponding states
map_state <- function(code) {
  if (code %in% c(09, 23, 25, 33, 44, 50, 34, 36, 42)) {
    return(1)
  } else if (code %in% c(18, 17, 26, 39, 55, 19, 20, 27, 29, 31, 38, 46)) {
    return(2)
  } else if (code %in% c(10, 11, 12, 13, 24, 37, 45, 51, 54, 01, 21, 28, 47, 05, 22, 40, 48)) {
    return(3)
  } else if (code %in% c(04, 08, 16, 35, 30, 49, 32, 56, 02, 06, 15, 41, 53)) {
    return(4)
  } else {
    return(NA)
  }
}

# Mutate a new variable 'state' based on the mapping function for each relevant column
reg_sub <- reg_sub %>%
  mutate(division_2001 = sapply(state_2001, map_state),
         division_2011 = sapply(state_2011, map_state))
```

1 = Northeast for code 09, 23,25,33,44,50,34,36,42

2 = Midwest for code 18,17,26,39,55,19,20,27,29,31,38,46

3 = South for code 10,11,12,13,24,37,45,51,54,01,21,28,47,05,22,40,48

4 = West for code 04,08,16,35,30,49,32,56,02,06,15,41,53

### Join ACL with region

```{r}
acl_sub2 <- left_join(acl_sub, select(reg_sub, V1, division_2001, division_2011), by = "V1")
```

### create response indicator

```{r}
# recode response indicator 
# note : 1=W5 Slf-Rep/2=W5 Proxy/3=W5 Non-Respondent/4=W5 Dead
acl_sub2$response_1986 <- as.numeric(substr(acl_sub2$response, 1, 1))
acl_sub2$response_1989 <- as.numeric(substr(acl_sub2$response, 2, 2))
acl_sub2$response_1994 <- as.numeric(substr(acl_sub2$response, 3, 3))
acl_sub2$response_2001 <- as.numeric(substr(acl_sub2$response, 4, 4))
acl_sub2$response_2011 <- as.numeric(substr(acl_sub2$response, 5, 5))
acl_sub2$response_2019 <- as.numeric(substr(acl_sub2$response, 6, 6))
```

```{r}
acl_sub2$proxy_2001 <- ifelse(acl_sub2$response_2001==2, 1, 0)
acl_sub2$proxy_2011 <- ifelse(acl_sub2$response_2011==2, 1, 0)
```

```{r}
# Recode values in columns 1-6
acl_sub2 <- acl_sub2 %>%
  mutate(
    response_1986 = case_when(response_1986 %in% c(1, 2) ~ "r", response_1986 == 3 ~ "nr", response_1986 == 4 ~ "d"),
    response_1989 = case_when(response_1989 %in% c(1, 2) ~ "r", response_1989 == 3 ~ "nr", response_1989 == 4 ~ "d"),
    response_1994 = case_when(response_1994 %in% c(1, 2) ~ "r", response_1994 == 3 ~ "nr", response_1994 == 4 ~ "d"),
    response_2001 = case_when(response_2001 %in% c(1, 2) ~ "r", response_2001 == 3 ~ "nr", response_2001 == 4 ~ "d"),
    response_2011 = case_when(response_2011 %in% c(1, 2) ~ "r", response_2011 == 3 ~ "nr", response_2011 == 4 ~ "d"),
    response_2019 = case_when(response_2019 %in% c(1, 2) ~ "r", response_2019 == 3 ~ "nr", response_2019 == 4 ~ "d")
  )
```

```{r}
table(acl_sub2$response_1986)
table(acl_sub2$response_1989)
table(acl_sub2$response_1994)
table(acl_sub2$response_2001)
table(acl_sub2$response_2011)
table(acl_sub2$response_2019)
```

### replace all 98 and 99 to NA

The data use negative value to represent missing value. I need to change that into NA. 

```{r}
acl_sub2 <- replace(acl_sub2, acl_sub2 == -6 | acl_sub2 == -96.0000000 | acl_sub2 == -98.0000000 | acl_sub2 == -99.0000000, NA)
```

Type of missing values  -99 , -98 , -97 , -96 , -95 , -94
 -6 is proxy respondent

### Check whether the sex is consistent over time

ACL does not provide the person identity. Therefore, I will use household information as weight, and apply the weight to individual data on 2019. 

Before that I need to make sure that the respondent does not change over time by checking their sex. Sex should be time invariant. 

```{r}
# test1 <- acl_sub2[acl_sub2$response_2001 == "r" & acl_sub2$response_2011 == "r" & acl_sub2$response_2019 == "r", ] 
```

```{r}
# #check sex
# test1$sex_code <- 0
# same_sex_rows <- which(
#   test1$sex_2001 == test1$sex_2011 & 
#   test1$sex_2011 == test1$sex_2019
# )
# test1$sex_code[same_sex_rows] <- 1
```

```{r}
# table(test1$sex_code)
```
The sex is consistent for 3 years for all respondent.

```{r}
# test1 <- test1[complete.cases(test1$age_2019), ]
# 
# # check age
# test1$agediff <- test1$age_2019 - test1$age_2011
# summary(test1$agediff)
# mean(test1$age_2019, na.rm = TRUE)
# mean(test1$age_2011)
```
All observation who response in 2001, 2011, 2019 has a age difference of 8 years. It means that the respondents are the same person. 

### Check non-response indicator

There is 39 observation which has nr status but it has income and weight data. I need to replace the status from nr to r. 

```{r}
test2 <- subset(acl_sub2, response_2019 == "nr" & !is.na(income_2019))
dim(test2)
```

```{r}
table(acl_sub2$response_2019)
```
Replace the nr status into r.

```{r}
acl_sub2$response_2019 <- ifelse(!is.na(acl_sub2$income_2019),
                               ifelse(acl_sub2$response_2019 == "nr", "r",
                                      acl_sub2$response_2019),acl_sub2$response_2019)
#& !is.na(acl_sub2$weight_2019)
```

```{r}
table(acl_sub2$response_2019)
```
This is the final response indcator. 

### Create attrition rate

```{r}
data <- acl_sub2
pycy=data[,grepl("response_",names(data))]

for (j in 1:dim(pycy)[2]){
  levels(pycy[,j])=c(levels(data[,names(pycy)[j]]),"bl")
  pycy[data[,names(pycy)[j]]=="",j]=gsub("","bl",pycy[data[,names(pycy)[j]]=="",j])
}

pycy$ID=1:dim(pycy)[1]
pycy$pid=data$pid

order_indices = do.call(order, pycy[, 1:6])
pycy_o = pycy[order_indices, ]

x=pycy_o$ID
y=names(pycy_o)[1:6]
pycy_data=expand.grid(X=x, Y=y)
pycy_data$X=factor(pycy_data$X, levels = factor(pycy_o$ID))
pycy_data$z= as.vector(as.matrix(pycy_o[,1:6]))

# Heatmap 
jpeg("attr_py.jpeg")
ggplot(pycy_data, aes(X, Y, fill= z)) + 
  geom_tile()+ scale_x_discrete("ID",breaks=NULL)+
  scale_y_discrete("Year",labels=c("1986","1989",
                                   "1994","2001",
                                   "2011","2019"))+
  scale_fill_manual(name="Type",values = c("d"="black", "nr"="yellow", "r"="blue"),
                    labels=c("Dead","NR","R"))+
  ggtitle("Response patterns")+theme_bw() +
  coord_flip()

dev.off()
```
```{r}
# Assuming your data frame is named 'acl_sub2'
library(dplyr)
library(tidyr)
library(ggplot2)

# Subset the relevant columns
responses_df <- acl_sub2[, c('response_1986', 'response_1989', 'response_1994', 
                             'response_2001', 'response_2011', 'response_2019')]

# create live status 
# Assuming your data frame is named 'df'
responses_df$survive_1986 <- ifelse(responses_df$response_1986 %in% c('r', 'nr'), 'alive', 'death')
responses_df$survive_1989 <- ifelse(responses_df$response_1989 %in% c('r', 'nr'), 'alive', 'death')
responses_df$survive_1994 <- ifelse(responses_df$response_1994 %in% c('r', 'nr'), 'alive', 'death')
responses_df$survive_2001 <- ifelse(responses_df$response_2001 %in% c('r', 'nr'), 'alive', 'death')
responses_df$survive_2011 <- ifelse(responses_df$response_2011 %in% c('r', 'nr'), 'alive', 'death')
responses_df$survive_2019 <- ifelse(responses_df$response_2019 %in% c('r', 'nr'), 'alive', 'death')

# subset the data 
survive_df <- responses_df[, c('survive_1986', 'survive_1989', 'survive_1994', 
                               'survive_2001', 'survive_2011', 'survive_2019')]


# Calculate the total count of each response type for each year
total_alive <- colSums(survive_df == 'alive')  
total_death <- colSums(survive_df == 'death')  

# Combine the total counts into a data frame
total_survive_df <- data.frame(
  Year = c(1986, 1989, 1994, 2001, 2011, 2019),
  Alive = total_alive,
  Death = total_death
)

# Calculate percentages
total_survive_df <- mutate(total_survive_df,
                           Alive_Percentage = (Alive / (Alive + Death)) * 100,
                           Death_Percentage = (Death / (Alive + Death)) * 100)

# Melt the data frame for easier plotting
melted_counts <- melt(total_survive_df, id.vars = "Year",
                      measure.vars = c("Alive_Percentage", "Death_Percentage"),
                      variable.name = "Vital_Status", value.name = "Percentage")

# Create the line chart with percentages
plot_response_percentage <- ggplot(melted_counts, aes(x = Year, y = Percentage, color = Vital_Status)) +
  geom_line(linewidth = 1.5) +
  labs(x = "Year", y = "Percentage", color = "Vital Status") +
  scale_x_continuous(breaks = c(1986, 1989, 1994, 2001, 2011, 2019)) +
  scale_color_manual(values = c('Alive_Percentage' = 'blue', 'Death_Percentage' = 'black')) + 
  theme_minimal()

# Show the plot with percentages
print(plot_response_percentage)

#ggsave("vital_plot.jpeg", plot = plot_response_percentage, device = "jpeg", width = 12, height = 6, units = "in")
```

```{r}
# Assuming your data frame is named 'df'
total_counts <- data.frame(
  Year = c(1986, 1989, 1994, 2001, 2011, 2019),
  r = colSums(responses_df[, c('response_1986', 'response_1989', 'response_1994', 'response_2001', 'response_2011', 'response_2019')] == 'r'),
  nr = colSums(responses_df[, c('response_1986', 'response_1989', 'response_1994', 'response_2001', 'response_2011', 'response_2019')] == 'nr'),
  d = colSums(responses_df[, c('response_1986', 'response_1989', 'response_1994', 'response_2001', 'response_2011', 'response_2019')] == 'd')
)

# Print the total counts
print(total_counts)
```
```{r}
total_counts$total = total_counts$r + total_counts$nr + total_counts$d
total_counts$target = total_counts$total - total_counts$d
total_counts$alive = total_counts$r + total_counts$nr
print(total_counts)
```
```{r}
total_counts$response = total_counts$r / (total_counts$r + total_counts$nr) * 100
total_counts$non_response = total_counts$nr / (total_counts$r + total_counts$nr) * 100
print(total_counts)
```
```{r}
#subset table 
table_alive <- total_counts[, c("Year", "response", "non_response")]

# Melt the data frame for easier plotting
melted_counts2 <- melt(table_alive, id.vars = "Year")

# Create the percentage line chart
plot_survive_percentage <- ggplot(melted_counts2, aes(x = Year, y = value, color = variable)) +
  geom_line(linewidth = 1.5) +
  labs(x = "Year", y = "Percentage", color = "Response Type") +
  scale_x_continuous(breaks = c(1986, 1989, 1994, 2001, 2011, 2019)) +
  scale_color_manual(values = c('response' = 'blue', 'non_response' = 'red')) +
  theme_minimal()

# Show the percentage line chart
print(plot_survive_percentage)
#ggsave("survive_plot.jpeg", plot = plot_survive_percentage, device = "jpeg", width = 12, height = 6, units = "in")
```
### Line chart

```{r}
# Filter rows where response_2019 is either "r" or "nr"
survive_only <- subset(responses_df, response_2019 == "r" | response_2019 == "nr")

# Recode nr into new columns
survive_only$attritor_1986 <- ifelse(survive_only$response_1986 == 'nr', 1, 0)
survive_only$attritor_1989 <- ifelse(survive_only$response_1986 == 'r' & survive_only$response_1989 == 'nr', 1, 0)
survive_only$attritor_1994 <- ifelse(survive_only$response_1986 == 'r' & survive_only$response_1989 == 'r' & survive_only$response_1994 == 'nr', 1, 0)
survive_only$attritor_2001 <- ifelse(survive_only$response_1986 == 'r' & survive_only$response_1989 == 'r' & survive_only$response_1994 == 'r' & survive_only$response_2001 == 'nr', 1, 0)
survive_only$attritor_2011 <- ifelse(survive_only$response_1986 == 'r' & survive_only$response_1989 == 'r' & survive_only$response_1994 == 'r' & survive_only$response_2001 == 'r' & survive_only$response_2011 == 'nr', 1, 0)
survive_only$attritor_2019 <- ifelse(survive_only$response_1986 == 'r' & survive_only$response_1989 == 'r' & survive_only$response_1994 == 'r' & survive_only$response_2001 == 'r' & survive_only$response_2011 == 'r' & survive_only$response_2019 == 'nr', 1, 0)

# Calculate the total count of each response type for each year
total_responses <- colSums(survive_only[, c("response_1986", "response_1989", "response_1994", "response_2001", "response_2011", "response_2019")] == 'r')  
total_responses_nr <- colSums(survive_only[, c("response_1986", "response_1989", "response_1994", "response_2001", "response_2011", "response_2019")] == 'nr')   
total_responses_nr_l <- colSums(survive_only[, c("attritor_1986", "attritor_1989", "attritor_1994", "attritor_2001", "attritor_2011", "attritor_2019")] == 1)

# Calculate percentages for each count
total_counts_df <- data.frame(
  Year = c(1986, 1989, 1994, 2001, 2011, 2019),
  Response = (total_responses / nrow(survive_only)) * 100,  # Calculate percentage for Response
  Non_Response = (total_responses_nr / nrow(survive_only)) * 100,  # Calculate percentage for Non_Response
  Non_Response_Long = (total_responses_nr_l / nrow(survive_only)) * 100  # Calculate percentage for Non_Response_Long
)

# Melt the data frame for easier plotting
melted_counts <- melt(total_counts_df, id.vars = "Year")

# Create the percentage line chart
plot_response_percentage_long <- ggplot(melted_counts, aes(x = Year, y = value, color = variable, linetype = variable)) +
  geom_line(size = 1.5) +
  labs(x = "Year", y = "Percentage", color = "Response Type", linetype = "Response Type",
       title = "Percentage of ACL Responses 1986-2019") +
  scale_x_continuous(breaks = c(1986, 1989, 1994, 2001, 2011, 2019)) +
  scale_color_manual(values = c('Response' = 'blue', 'Non_Response' = 'red', 'Non_Response_Long' = 'orange')) +
  scale_linetype_manual(values = c('Response' = 'solid', 'Non_Response' = 'solid', 'Non_Response_Long' = 'dashed')) + 
  theme_minimal()

# Show the percentage line chart
print(plot_response_percentage_long)

ggsave("responselong_plot.jpeg", plot = plot_response_percentage_long, device = "jpeg", width = 12, height = 6, units = "in")
```


```{r}
# total_counts_df
# plot_response
# ggsave("attrition_plots.jpeg", plot = plot_response, device = "jpeg", width = 12, height = 6, units = "in")
```

This table represents cross sectional response rate. 

### Create longitudinal response rate

```{r}
responses_longit <- responses_df
```

```{r}
# Assuming your data frame is named 'acl_sub2'
responses_longit$responselong_1994 <- ifelse(responses_longit$response_1989 == 'r' & responses_longit$response_1994 == 'r', 1, 0)

responses_longit$responselong_2001 <- ifelse(responses_longit$response_1989 == 'r' & responses_longit$response_1994 == 'r' & responses_longit$response_2001 == 'r', 1, 0)

responses_longit$responselong_2011 <- ifelse(responses_longit$response_1989 == 'r' & responses_longit$response_1994 == 'r' & responses_longit$response_2001 == 'r' & responses_longit$response_2011 == 'r', 1, 0)

responses_longit$responselong_2019 <- ifelse(responses_longit$response_1989 == 'r' & responses_longit$response_1994 == 'r' & responses_longit$response_2001 == 'r' & responses_longit$response_2011 == 'r' & responses_longit$response_2019 == 'r', 1, 0)
```

```{r}
head(responses_longit)
```
```{r}
# Assuming your data frame is named 'acl_sub2'
totals <- colSums(responses_longit[, c("responselong_1994", "responselong_2001", "responselong_2011", "responselong_2019")])
totals
```
### Compute Attrition

```{r}
responses_longit$attritor_1989 <- ifelse(responses_longit$response_1986 == 'r' & responses_longit$response_1989 == 'nr', 1, 0)

responses_longit$attritor_1994 <- ifelse(responses_longit$response_1986 == 'r' & responses_longit$response_1989 == 'r' & responses_longit$response_1994 == 'nr', 1, 0)

responses_longit$attritor_2001 <- ifelse(responses_longit$response_1986 == 'r' & responses_longit$response_1989 == 'r' & responses_longit$response_1994 == 'r' & responses_longit$response_2001 == 'nr', 1, 0)

responses_longit$attritor_2011 <- ifelse(responses_longit$response_1986 == 'r' & responses_longit$response_1989 == 'r' & responses_longit$response_1994 == 'r' & responses_longit$response_2001 == 'r' & responses_longit$response_2011 == 'nr', 1, 0)

responses_longit$attritor_2019 <- ifelse(responses_longit$response_1986 == 'r' & responses_longit$response_1989 == 'r' & responses_longit$response_1994 == 'r' & responses_longit$response_2001 == 'r' & responses_longit$response_2011 == 'r' & responses_longit$response_2019 == 'nr', 1, 0)
```

```{r}
# Assuming your data frame is named 'acl_sub2'
totals2 <- colSums(responses_longit[, c("attritor_1989", "attritor_1994", "attritor_2001", "attritor_2011", "attritor_2019")])
totals2
```

### Compute response rate

```{r}
acl_response  <- acl_data[,c("ï..V1", "V2", "V22009")]
```

```{r}
# Assuming your data frame is named 'your_data'
# Create a new column for each digit in the response
acl_response$response_1986 <- as.numeric(substr(acl_response$V22009, 1, 1))
acl_response$response_1989 <- as.numeric(substr(acl_response$V22009, 2, 2))
acl_response$response_1994 <- as.numeric(substr(acl_response$V22009, 3, 3))
acl_response$response_2001 <- as.numeric(substr(acl_response$V22009, 4, 4))
acl_response$response_2011 <- as.numeric(substr(acl_response$V22009, 5, 5))
acl_response$response_2019 <- as.numeric(substr(acl_response$V22009, 6, 6))
```

```{r}
acl_response$proxy_2001 <- ifelse(acl_response$response_2001==2, 1, 0)
acl_response$proxy_2011 <- ifelse(acl_response$response_2011==2, 1, 0)
```

```{r}
# Recode values in columns 1-6

acl_response <- acl_response %>%
  mutate(
    response_1986 = case_when(response_1986 %in% c(1, 2) ~ "r", response_1986 == 3 ~ "nr", response_1986 == 4 ~ "d"),
    response_1989 = case_when(response_1989 %in% c(1, 2) ~ "r", response_1989 == 3 ~ "nr", response_1989 == 4 ~ "d"),
    response_1994 = case_when(response_1994 %in% c(1, 2) ~ "r", response_1994 == 3 ~ "nr", response_1994 == 4 ~ "d"),
    response_2001 = case_when(response_2001 %in% c(1, 2) ~ "r", response_2001 == 3 ~ "nr", response_2001 == 4 ~ "d"),
    response_2011 = case_when(response_2011 %in% c(1, 2) ~ "r", response_2011 == 3 ~ "nr", response_2011 == 4 ~ "d"),
    response_2019 = case_when(response_2019 %in% c(1, 2) ~ "r", response_2019 == 3 ~ "nr", response_2019 == 4 ~ "d")
  )
```

### Check unit non-response

### subset data only for those response in 2001 and 2019

```{r}
acl_sub3 <- acl_sub2[acl_sub2$response_1989=="r" & acl_sub2$response_1994=="r" & acl_sub2$response_2001=="r" & acl_sub2$response_2011=="r",] 
```

```{r}
dim(acl_sub3) # 1071   24
```
This is the final dimension after filtering respondent who response only in 2001 and 2011. 

### Check response of 2019 after filtering

```{r}
table(acl_sub3$response_2019) # d  nr   r  # 223 299 659
```

### Check weight, make sure weight 2001, 2011 is non zero)

```{r}
summary(acl_sub3$weight_2001) #Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 0.04833 0.49868 1.07673 1.14796 1.61017 5.71707 
summary(acl_sub3$weight_2011) # Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 0.05017 0.43576 0.94986 1.04027 1.50484 5.65662
```
```{r}
ext8 <- subset(acl_sub3, is.na(weight_2001))
dim(acl_sub3)
```

```{r}
#subset data for acl that have non-zero longitudinal weight
acl_sub3 <- acl_sub3[!is.na(acl_sub3$weight_2001) & !is.na(acl_sub3$weight_2011), ]
```

```{r}
dim(acl_sub3)
```
```{r}
# check weight summary
summary(acl_sub3$weight_2001)  
summary(acl_sub3$weight_2011)
```
```{r}
table(acl_sub3$weight_2001==0)
table(acl_sub3$weight_2011==0)
```
All weight is non zero. Go ahead. 

### Check item non response

```{r}
colnames(acl_sub3)
```
```{r}
summary_stats <- lapply(acl_sub3[,c(3:5, 7:8, 16:25)], count_missing_categorical)
column_summary <- sapply(summary_stats, function(x) x)
print(column_summary)
```

```{r}
# no sex imputation
#acl_sub3$sex_2001 <- ifelse(is.na(acl_sub3$sex_2001), acl_sub3$sex_2011, acl_sub3$sex_2001)
```

### Check division

```{r}
# test3 <- left_join(acl_sub, select(reg_sub, V1, state_2001, state_2011, division_2001, division_2011), by = "V1")
```

```{r}
# test3$response_1986 <- as.numeric(substr(test3$response, 1, 1))
# test3$response_1989 <- as.numeric(substr(test3$response, 2, 2))
# test3$response_1994 <- as.numeric(substr(test3$response, 3, 3))
# test3$response_2001 <- as.numeric(substr(test3$response, 4, 4))
# test3$response_2011 <- as.numeric(substr(test3$response, 5, 5))
# test3$response_2019 <- as.numeric(substr(test3$response, 6, 6))
```

```{r}
# Recode values in columns 1-6
# test3 <- test3 %>%
#   mutate(
#     response_1986 = case_when(response_1986 %in% c(1, 2) ~ "r", response_1986 == 3 ~ "nr", response_1986 == 4 ~ "d"),
#     response_1989 = case_when(response_1989 %in% c(1, 2) ~ "r", response_1989 == 3 ~ "nr", response_1989 == 4 ~ "d"),
#     response_1994 = case_when(response_1994 %in% c(1, 2) ~ "r", response_1994 == 3 ~ "nr", response_1994 == 4 ~ "d"),
#     response_2001 = case_when(response_2001 %in% c(1, 2) ~ "r", response_2001 == 3 ~ "nr", response_2001 == 4 ~ "d"),
#     response_2011 = case_when(response_2011 %in% c(1, 2) ~ "r", response_2011 == 3 ~ "nr", response_2011 == 4 ~ "d"),
#     response_2019 = case_when(response_2019 %in% c(1, 2) ~ "r", response_2019 == 3 ~ "nr", response_2019 == 4 ~ "d")
#   )
```

```{r}
# test3 <- test3[test3$response_2001=="r" & test3$response_2011=="r",] 
```

```{r}
# test3 <- test3[is.na(acl_sub3$division_2001) | is.na(test3$division_2011), ]
```

```{r}
# test3 <- acl_sub2[acl_sub2$response_2001=="r" & acl_sub2$response_2011=="r",] 
```

The missing region is caused by the missing state. Should I assume that they did not relocate?

Should check the state before and after the period. 

```{r}
# test4 <- left_join(acl_sub, select(acl_region, V1, V22213, V22218, V22223, V22228, V22233,V22238), by = "V1")
```

```{r}
# test4$response_1986 <- as.numeric(substr(test4$response, 1, 1))
# test4$response_1989 <- as.numeric(substr(test4$response, 2, 2))
# test4$response_1994 <- as.numeric(substr(test4$response, 3, 3))
# test4$response_2001 <- as.numeric(substr(test4$response, 4, 4))
# test4$response_2011 <- as.numeric(substr(test4$response, 5, 5))
# test4$response_2019 <- as.numeric(substr(test4$response, 6, 6))
```

```{r}
# Recode values in columns 1-6
# test4 <- test4 %>%
#   mutate(
#     response_1986 = case_when(response_1986 %in% c(1, 2) ~ "r", response_1986 == 3 ~ "nr", response_1986 == 4 ~ "d"),
#     response_1989 = case_when(response_1989 %in% c(1, 2) ~ "r", response_1989 == 3 ~ "nr", response_1989 == 4 ~ "d"),
#     response_1994 = case_when(response_1994 %in% c(1, 2) ~ "r", response_1994 == 3 ~ "nr", response_1994 == 4 ~ "d"),
#     response_2001 = case_when(response_2001 %in% c(1, 2) ~ "r", response_2001 == 3 ~ "nr", response_2001 == 4 ~ "d"),
#     response_2011 = case_when(response_2011 %in% c(1, 2) ~ "r", response_2011 == 3 ~ "nr", response_2011 == 4 ~ "d"),
#     response_2019 = case_when(response_2019 %in% c(1, 2) ~ "r", response_2019 == 3 ~ "nr", response_2019 == 4 ~ "d")
#   )
```

```{r}
# test5 <- test4[test4$response_2001=="r" & test4$response_2011=="r",] 
```

```{r}
# test6 <- test5[is.na(test5$V22228) | is.na(test5$V22233), ]
```

After checking back to the raw data, these 5 respondent lived in the same location in 1994, 2001, 2011, and 2019. Therefore I can fill out the missing data based on the information from previous or after years, assuming that they did not relocate. 

### Impute division (back to acl_sub3)

```{r}
acl_sub3$division_2001 <- ifelse(is.na(acl_sub3$division_2001), acl_sub3$division_2011, acl_sub3$division_2001)
acl_sub3$division_2011 <- ifelse(is.na(acl_sub3$division_2011), acl_sub3$division_2001, acl_sub3$division_2011)
```

### Check result after imputing division

```{r}
summary_stats <- lapply(acl_sub3[,c(3:5, 7:8, 16:25)], count_missing_categorical)
column_summary <- sapply(summary_stats, function(x) x)
print(column_summary)
```

### Check summary of numeric data

```{r}
summary(acl_sub3$age_2011)
summary(acl_sub3$age_2019) # 2019 is fine to have NA
summary(acl_sub3$income_2001)
summary(acl_sub3$income_2011)
summary(acl_sub3$income_2019) # 2019 is fine to have NA
quantile(acl_sub3$income_2001, probs = c(0.10, 0.25, 0.50, 0.75, 0.90))
quantile(acl_sub3$income_2011, probs = c(0.10, 0.25, 0.50, 0.75, 0.90))
```

```{r}
table(acl_sub3$sex_2001)
table(acl_sub3$sex_2011)
table(acl_sub3$sex_2019)
```
We don't have negative income. 
The data is complete. 

### Check income trend

We want to know whether the respondent with increasing trend of income has a different response propensity that respondent who has a decreasing or constant trend of income. Therefore, we checked the income trend. 

### check income trend (response)

```{r}
data_plot_r <- subset(acl_sub3, response_2019=="r")
data_plot_r <- data_plot_r[,c("V2", "income_2001","income_2011","income_2019")]

set.seed(42) #take sample of 20 observation
sample_plot_r <- data_plot_r[sample(nrow(data_plot_r), 40), ]
colnames(sample_plot_r) <- c("pid", "2001", "2011", "2019")
sample_long_r <- gather(sample_plot_r, key = "year", value = "income", -pid)
sample_long_r$pid <- as.numeric(sample_long_r$pid)
sample_long_r$year <- as.numeric(sample_long_r$year)
# Create the plot
ggplot(sample_long_r, aes(x = year, y = income, group = pid, color = factor(pid))) +
  geom_line() +
  geom_point() +
  labs(x = "Year", y = "Income", color = "pid") +
  theme_minimal() +
  scale_x_continuous(breaks = c(2001, 2011, 2019))
```
### check income trend (non-response)

```{r}
data_plot_nr <- subset(acl_sub3, response_2019=="nr")
data_plot_nr <- data_plot_nr[,c("V2", "income_2001","income_2011")]

set.seed(42) #take sample of 20 observation
sample_plot_nr <- data_plot_nr[sample(nrow(data_plot_nr), 40), ]
colnames(sample_plot_nr) <- c("pid", "2001", "2011")
sample_long_nr <- gather(sample_plot_nr, key = "year", value = "income", -pid)
sample_long_nr$pid <- as.numeric(sample_long_nr$pid)
sample_long_nr$year <- as.numeric(sample_long_nr$year)
# Create the plot
ggplot(sample_long_nr, aes(x = year, y = income, group = pid, color = factor(pid))) +
  geom_line() +
  geom_point() +
  labs(x = "Year", y = "Income", color = "pid") +
  theme_minimal() +
  scale_x_continuous(breaks = c(2001, 2011))
```

### check income trend (death)

```{r}
data_plot_d <- subset(acl_sub3, response_2019=="d")
data_plot_d <- data_plot_d[,c("V2", "income_2001","income_2011")]

set.seed(42) #take sample of 20 observation
sample_plot_d <- data_plot_d[sample(nrow(data_plot_d), 40), ]
colnames(sample_plot_d) <- c("pid", "2001", "2011")
sample_long_d <- gather(sample_plot_d, key = "year", value = "income", -pid)
sample_long_d$pid <- as.numeric(sample_long_d$pid)
sample_long_d$year <- as.numeric(sample_long_d$year)

# Create the plot
ggplot(sample_long_d, aes(x = year, y = income, group = pid, color = factor(pid))) +
  geom_line() +
  geom_point() +
  labs(x = "Year", y = "Income", color = "pid") +
  theme_minimal() +
  scale_x_continuous(breaks = c(2001, 2011))
```
### Check growth of income

### Overall

```{r}
acl_sub3$growth <- (acl_sub3$income_2011-acl_sub3$income_2001)/abs(acl_sub3$income_2001)
summary(acl_sub3$growth) # Min.  1st Qu.   Median     Mean  3rd Qu.     Max. -0.92727 -0.30000  0.08571  0.27825  0.50000 19.00000 
hist(acl_sub3$growth)
```

### Response

```{r}
data_plot_r$growth <- (data_plot_r$income_2011-data_plot_r$income_2001)/abs(data_plot_r$income_2001)
summary(data_plot_r$growth) # Min. 1st Qu.  Median    Mean 3rd Qu.    Max. -0.9273 -0.2505  0.1111  0.2885  0.5000 16.0000 
hist(data_plot_r$growth)
```
### Non-Response

```{r}
data_plot_nr$growth <- (data_plot_nr$income_2011-data_plot_nr$income_2001)/abs(data_plot_nr$income_2001)
summary(data_plot_nr$growth) #Min.  1st Qu.   Median     Mean  3rd Qu.     Max. -0.92156 -0.32989  0.09494  0.31228  0.50000 19.00000
hist(data_plot_nr$growth)
```
### Death

```{r}
data_plot_d$growth <- (data_plot_d$income_2011-data_plot_d$income_2001)/abs(data_plot_d$income_2001)
summary(data_plot_d$growth) # Min.  1st Qu.   Median     Mean  3rd Qu.     Max. -0.90585 -0.36339  0.01796  0.20231  0.49138  5.96816
hist(data_plot_d$growth)
```

As they are getting older, the salary is getting lower. 

### Compute response rate

```{r}
sum(acl_sub3$response_2019 == "r") / length(acl_sub3$response_2019)
sum(acl_sub3$response_2019 == "nr") / length(acl_sub3$response_2019)
sum(acl_sub3$response_2019 == "d") / length(acl_sub3$response_2019)
```

```{r}
acl_res_2019 <- subset(acl_sub3, response_2019 %in% c("r", "nr"))
dim(acl_res_2019)
```
```{r}
sum(acl_res_2019$response_2019 == "r") / length(acl_res_2019$response_2019)
sum(acl_res_2019$response_2019 == "nr") / length(acl_res_2019$response_2019)
```

The response rate for 2019 is 55.8 percent, non response rate is 25.31 percent, the death rate is 18.88 percent. 

### Recode Variables

** Categorical Variables:

response_2019: 1 = r 2 = nr 3 = d ## the reference is “r”

race: The original race category is : 1 WHITE 2 BLACK 3 AMER IND 4 ASIAN 5 HISPAN, I change into 1 = Non Black 2 = Black  ##The reference is “1”

sex: 1 = Male 2 = Female ## Reference is 1 “male”

age: 1=0-29 2=30-54 3=55+

```{r}
#create factor for response
acl_sub3$response_2019 <- factor(acl_sub3$response_2019, levels=c("r","nr","d"))
acl_sub3$response_2019 <- relevel(acl_sub3$response_2019, ref="r") 
```

```{r}
#create factor for sex
acl_sub3$sex_2001 <- factor(acl_sub3$sex_2001, levels=c("1","2"))
acl_sub3$sex_2001 <- relevel(acl_sub3$sex_2001, ref="1") 
```

```{r}
#create factor for race
acl_sub3 <- acl_sub3 %>%
  mutate(race_cat = case_when(
    race_1968 %in% c(1, 3, 4, 5) ~ 1,
    race_1968 == 2 ~ 2,
  ))

acl_sub3$race_cat <- factor(acl_sub3$race_cat, levels=c("1","2"))
acl_sub3$race_cat <- relevel(acl_sub3$race_cat, ref="1")
```

```{r}
#create factor for age
acl_age <- acl_sub3[,grepl("age_", names(acl_sub3))]
for (i in 1:ncol(acl_age)){
acl_age[,2+i] <- case_when(
    acl_age[,i] >= 45 & acl_age[,i] <= 64 ~ "1",
    acl_age[,i] >= 65 & acl_age[,i] <= 79 ~ "2",
    acl_age[,i] >= 80 ~ "3"
)
}

year_age <- substr(names(acl_age[, c(1:2)]), start = 5, stop = 8)
year_age <- ifelse(nchar(year_age) == 1, paste0("0", year_age), year_age)
colnames(acl_age)[c(3:4)] <- paste0("AgeCat_", year_age)
```

```{r}
#create factor for division
acl_region <- acl_sub3[, grepl("division", names(acl_sub3))] %>% as.data.frame()
for (i in 1:ncol(acl_region )) {
  acl_region [, i] <- factor(acl_region [, i], levels = c("1", "2", "3", "4"), ordered = FALSE)
  acl_region [, i] <- relevel(acl_region [, i], ref = "1") ## foreign country
}
```

```{r}
#combine all into one dataset
acl_new <- cbind(acl_sub3[,c("V1", "V2", "response_2019","sex_2001","sex_2019", "race_cat")], acl_age[,c("AgeCat_2011", "AgeCat_2019")], acl_sub3[,c("division_2001", "division_2011", "weight_2001", "weight_2011",  "proxy_2001", "proxy_2011")])
#"weight_2019",
```

### Transformation of income

### Log Income

```{r}
acl_log <- acl_sub3[,c(grepl("income_", names(acl_sub3)))]

for (i in 1:ncol(acl_log)){
  acl_log[,3+i] <- log(acl_log[,i]+1)
}

year_log <- substr(names(acl_log[, c(1:3)]), start = 8, stop = 11)
year_log <- ifelse(nchar(year_log) == 1, paste0("0", year_log), year_log)
colnames(acl_log)[c(4:6)] <- paste0("log_inc_", year_log)

acl_new <- cbind(acl_new, acl_log)
```

### Cubic transformation

```{r}
#cubic transformation for income
acl_cube <- acl_sub3[,c(grepl("income_", names(acl_sub3)))]

for (i in 1:ncol(acl_cube)){
  acl_cube[,3+i] <- (sign(acl_cube[,i]))*(abs(acl_cube[,i]))^(1/3)
}

year_cube <- substr(names(acl_cube[, c(1:3)]), start = 8, stop = 11)
year_cube <- ifelse(nchar(year_cube) == 1, paste0("0", year_cube), year_cube)
colnames(acl_cube)[c(4:6)] <- paste0("cube_inc_", year_cube)

acl_new <- cbind(acl_new, acl_cube[,c(4:6)])
```

### 10% and 90% binary of income

```{r}
#create categorical income

#get data from acl_sub2
acl_inc_l <- acl_sub3[,grepl("income_", names(acl_sub3))]
acl_inc_h <- acl_sub3[,grepl("income_", names(acl_sub3))]

#recode the total family income for 10% and 90% binary
for (i in 1:ncol(acl_inc_l)){
  df_acl <- acl_inc_l[acl_inc_l[,i] != 0,i]
  critical_value <- quantile(df_acl, c(0.10), na.rm=TRUE)
  acl_inc_l[,3+i] <- case_when(
    acl_inc_l[,i] <= critical_value[1]~ "1",
    acl_inc_l[,i] > critical_value[1]~ "0"
)
  
  df_acl <- acl_inc_h[acl_inc_h[,i] != 0,i]
  critical_value <- quantile(df_acl, c(0.90), na.rm=TRUE)
  acl_inc_h[,3+i] <- case_when(
    acl_inc_h[,i] >= critical_value[1]~ "1",
    acl_inc_h[,i] < critical_value[1]~ "0"
)
}

year_inc <- substr(names(acl_inc_l[, c(1:3)]), start = 8, stop = 11)
year_inc <- ifelse(nchar(year_inc) == 1, paste0("0", year_inc), year_inc)
colnames(acl_inc_l)[c(4:6)] <- paste0("TotInc_l_", year_inc)
colnames(acl_inc_h)[c(4:6)] <- paste0("TotInc_h_", year_inc)

acl_new <- cbind(acl_new, acl_inc_l[,c(4:6)], acl_inc_h[,c(4:6)])
```

### growth of income

```{r}
acl_new$growth <- (acl_new$income_2011-acl_new$income_2001)/abs(acl_new$income_2001)
summary(acl_new$growth)
```

### categorize quantile of growth

```{r}
quantiles <- quantile(acl_new$growth, probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE)
quantile_labels <- c("1","2","3","4")
growth_quantiles <- cut(acl_new$growth, breaks = quantiles, labels = quantile_labels, include.lowest = TRUE)
acl_new <- cbind(acl_new, growth_quantiles)
```

### standardize cube of income

```{r}
#standardized of cube income
acl_new$std_cube_2001 <- (acl_new$cube_inc_2001 - mean(acl_new$cube_inc_2001)) / sd(acl_new$cube_inc_2001)
acl_new$std_cube_2011  <- (acl_new$cube_inc_2011 - mean(acl_new$cube_inc_2011)) / sd(acl_new$cube_inc_2011)
```

```{r}
# check the result
summary(acl_new$std_cube_2001) #Min.   1st Qu.    Median      Mean   3rd Qu.      Max. -1.974748 -0.648300  0.009915  0.000000  0.591391  9.275817 
summary(acl_new$std_cube_2011) #Min. 1st Qu.  Median    Mean 3rd Qu.    Max. -2.1064 -0.7133 -0.1362  0.0000  0.5406 10.4399 
```
### Standardize log of income

```{r}
#add standardization of log income
acl_new$std_log_2001 <- (acl_new$log_inc_2001-mean(acl_new$log_inc_2001))/ sd(acl_new$log_inc_2001)
acl_new$std_log_2011 <- (acl_new$log_inc_2011-mean(acl_new$log_inc_2011))/ sd(acl_new$log_inc_2011)
```

### Proxy as factor

```{r}
acl_new$proxy_2011 <- as.factor(acl_new$proxy_2011)
```

### Check the categorization result

```{r}
table(acl_new$response_2019, acl_new$sex_2001)
table(acl_new$response_2019, acl_new$sex_2019) #fine for sex2019 to be empty
```

```{r}
table(acl_new$response_2019, acl_new$race_cat)
```
The observation is race 3 and death is too few. 

```{r}
table(acl_new$response_2019, acl_new$AgeCat_2011) 
table(acl_new$response_2019, acl_new$AgeCat_2019)
```
The age for 2019 is on the 3rd group only. I need to think more about this. 

```{r}
table(acl_new$response_2019, acl_new$TotInc_l_2001)
```

```{r}
table(acl_new$response_2019, acl_new$TotInc_l_2011)
```

```{r}
table(acl_new$response_2019, acl_new$TotInc_h_2001)
```

```{r}
table(acl_new$response_2019, acl_new$TotInc_h_2011)
```

```{r}
table(acl_new$response_2019, acl_new$growth_quantiles)
```
```{r}
table(acl_new$response_2019, acl_new$proxy_2001)
```

```{r}
table(acl_new$response_2019, acl_new$proxy_2011)
```


```{r}
summary_stats <- lapply(acl_new[,c(3:35)], count_missing_categorical)
column_summary <- sapply(summary_stats, function(x) x)
print(column_summary)
```

### Descriptive Statistics

```{r Sample characteristics, warning=FALSE, message=FALSE}
#Preparing table for initial descriptive statistics
set_gtsummary_theme(theme_gtsummary_compact(set_theme = TRUE))

#To get the descriptives
des1 <- acl_new %>%
  dplyr::select(sex_2001, race_cat, AgeCat_2011, division_2001, division_2011, weight_2001, weight_2011, proxy_2011, TotInc_l_2001, TotInc_l_2011, TotInc_h_2001, TotInc_h_2011,  growth, growth_quantiles) %>%
            tbl_summary(
              type = list(all_dichotomous() ~ "categorical",
                          all_continuous() ~ "continuous"),
              statistic = list(all_continuous() ~ "{mean} ({sd})",
                          all_categorical() ~ "{n} ({p}%)"),
              percent = "column",
              digits = all_continuous() ~ 1) %>%  
  bold_labels() %>% 
  italicize_levels() %>% 
  as_flex_table()

des1
```

```{r}
# Reorder levels of response_2019
acl_new$response_2019 <- fct_relevel(acl_new$response_2019, "r", "nr", "d")

# Preparing table for initial descriptive statistics
set_gtsummary_theme(theme_gtsummary_compact(set_theme = TRUE))

# Selecting specific variables
selected_vars <- c("response_2019", "sex_2001", "race_cat", "AgeCat_2011", 
                   "division_2001", "division_2011","TotInc_l_2001", "TotInc_l_2011", "TotInc_h_2001", "TotInc_h_2011",
                   "growth", "growth_quantiles", "weight_2001", "weight_2011",
                   "proxy_2011")

# To get the descriptives based on selected variables and response_2019
des2 <- tbl_summary(acl_new %>%
                      dplyr::select(all_of(selected_vars)),
                    by = response_2019,
                    statistic = list(all_continuous() ~ "{mean} ({sd})", all_categorical() ~ "{n} ({p}%)"),
                    percent = "column",
                    digits = all_continuous() ~ 1
) %>%
  bold_labels() %>%
  italicize_levels()

des2

```

### Summary of income distribution

```{r}
# Compute quantiles and mean for each response type
quantiles_and_mean_2001 <- by(acl_sub3$income_2001, acl_sub3$response_2019, FUN = function(x) c(mean(x), quantile(x, probs = c(0.10, 0.25, 0.50, 0.75, 0.90))))
quantiles_and_mean_2011 <- by(acl_sub3$income_2011, acl_sub3$response_2019, FUN = function(x) c(mean(x), quantile(x, probs = c(0.10, 0.25, 0.50, 0.75, 0.90))))

# Print the computed quantiles and mean
print(quantiles_and_mean_2001)
print(quantiles_and_mean_2011)

summary(acl_new$income_2001)
summary(acl_new$income_2011)
```
### Weighted Descriptive Statistics

```{r}
acl.2019.design <- svydesign(data=acl_new, 
                             id = ~1,
                            weights = ~weight_2011)
```

### 2001 Variables

```{r}
svyby(~sex_2001, by = ~response_2019, design = acl.2019.design, svymean)
```

```{r}
svyby(~race_cat, by = ~response_2019, design = acl.2019.design, svymean)
```

```{r}
svyby(~AgeCat_2011, by = ~response_2019, design = acl.2019.design, svymean)
```

```{r}
svyby(~division_2011, by = ~response_2019, design = acl.2019.design, svymean)
```

```{r}
svyby(~TotInc_l_2011, by = ~response_2019, design = acl.2019.design, svymean)
```
```{r}
svyby(~TotInc_h_2011, by = ~response_2019, design = acl.2019.design, svymean)
```

```{r}
svyby(~growth, by = ~response_2019, design = acl.2019.design, svymean)
```
```{r}
svyby(~growth_quantiles, by = ~response_2019, design = acl.2019.design, svymean)
```

```{r}
svyby(~weight_2011, by = ~response_2019, design = acl.2019.design, svymean)
```
```{r}
svyby(~proxy_2011, by = ~response_2019, design = acl.2019.design, svymean)
```

### Variables 2001

```{r}
acl.2019.design.2 <- svydesign(data=acl_new, 
                             id = ~1,
                            weights = ~weight_2001)
```


```{r}
svyby(~division_2001, by = ~response_2019, design = acl.2019.design.2, svymean)
```

```{r}
svyby(~TotInc_l_2001, by = ~response_2019, design = acl.2019.design.2, svymean)
```

```{r}
svyby(~TotInc_l_2001, by = ~response_2019, design = acl.2019.design.2, svymean)
```

### Income Distribution

```{r}
svyby(~income_2011, by=~response_2019, design = acl.2019.design, c(.10, .25, .50, .75, .90), FUN=svyquantile)
```

```{r}
svyby(~income_2011, by=~response_2019, design = acl.2019.design, FUN=svymean)
```
```{r}
svyby(~income_2001, by=~response_2019, design = acl.2019.design.2, c(.10, .25, .50, .75, .90), FUN=svyquantile)
```

```{r}
svyby(~income_2001, by=~response_2019, design = acl.2019.design.2, FUN=svymean)
```


### Check the normality of the income transformation

```{r}
# original income
a <- ggplot(acl_new, aes(sample = income_2001)) +
  stat_qq() +
  stat_qq_line() +
  theme_minimal() +
  xlab("Income 2001")

# log income
b <- ggplot(acl_new, aes(sample = log_inc_2001)) +
  stat_qq() +
  stat_qq_line() +
  theme_minimal()+
  xlab("Log Income 2001")

# cube income
c <- ggplot(acl_new, aes(sample = cube_inc_2001)) +
  stat_qq() +
  stat_qq_line() +
  theme_minimal() +
  xlab("Cube Income 2001")

combined_plots1 <- ggarrange(a,b,c, ncol = 3, nrow = 1)
combined_plots1
# ggsave("combined_qq_plots1.jpeg", plot = combined_plots1, device = "jpeg", width = 12, height = 6, units = "in")
```
In 2001, log income looks better than original income and cube income. 

```{r}
# original income
d <- ggplot(acl_new, aes(sample = income_2011)) +
  stat_qq() +
  stat_qq_line() +
  theme_minimal() +
  xlab("Income 2011")

# log income
e <- ggplot(acl_new, aes(sample = log_inc_2011)) +
  stat_qq() +
  stat_qq_line() +
  theme_minimal() +
  xlab("Log Income 2011")

# cube income
f <- ggplot(acl_new, aes(sample = cube_inc_2011)) +
  stat_qq() +
  stat_qq_line() +
  theme_minimal() +
  xlab("Cube Income 2011")

combined_plots2 <- ggarrange(d,e,f, ncol = 3, nrow = 1)
combined_plots2
# ggsave("combined_qq_plots2.jpeg", plot = combined_plots2, device = "jpeg", width = 12, height = 6, units = "in")
```

In 2011, log income looks better than cube income. I will use log for the next steps. 

### Check the data structures before modelling

```{r}
str(acl_new)
```

```{r}
acl_new$race_cat <- factor(acl_new$race_cat, levels=c("1","2"))
acl_new$race_cat <- relevel(acl_new$race_ca , ref="1")
```

```{r}
acl_new$AgeCat_2011 <- factor(acl_new$AgeCat_2011, levels=c("1","2","3"))
acl_new$AgeCat_2011 <- relevel(acl_new$AgeCat_2011, ref="1")
```

```{r}
acl_new$division_2001 <- factor(acl_new$division_2001, levels=c("1","2","3","4"))
acl_new$division_2001 <- relevel(acl_new$division_2001, ref="1")
```

```{r}
acl_new$division_2011 <- factor(acl_new$division_2011, levels=c("1","2","3","4"))
acl_new$division_2011 <- relevel(acl_new$division_2011, ref="1")
```

```{r}
#acl_new$proxy_2001 <- factor(acl_new$proxy_2001, levels=c("0","1"))
#acl_new$proxy_2001 <- relevel(acl_new$proxy_2001, ref="0")
```

```{r}
acl_new$proxy_2011 <- factor(acl_new$proxy_2011, levels=c("0","1"))
acl_new$proxy_2011 <- relevel(acl_new$proxy_2011, ref="0")
```

### Starts the modelling process

The goal is to construct the best model to predict the response, non-response, and death. 

The outcome is the response indicator for 2019, the predictors are from 2001 and 2011. 

### Model 1

```{r}
#create model
df.1 <- acl_new
fit.1 <- multinom(response_2019 ~ TotInc_l_2001 + TotInc_l_2011 + TotInc_h_2001 + TotInc_h_2011 + sex_2001 + race_cat + AgeCat_2011 + division_2001 + division_2011 + weight_2001 + weight_2011 + proxy_2011, data = df.1)

#summary
summary(fit.1)

# Print the model summary
kable(tidy(fit.1))
```

The significant variables for nr : TotInc_l_20111, AgeCat_20112, AgeCat_20113, proxy_20111. 

The significant variables for d : TotInc_l_20111, AgeCat_20112, AgeCat_20113, proxy_20111. 

### Compute the predicted probability

```{r}
# predicted probability
pred_prob <- predict(fit.1, newdata = df.1, type = "probs")[,1]
df.1$pred_prob <- pred_prob
summary(df.1$pred_prob)
```
### Evaluate the model

```{r}
# Calculate OvA AUC for each class
class_auc <- numeric(length(levels(df.1$response_2019)))
for (i in seq_along(class_auc)) {
  true_labels <- as.numeric(df.1$response_2019 == levels(df.1$response_2019)[i])
  pred_scores <- pred_prob
  roc_curve <- roc(true_labels, pred_scores)
  class_auc[i] <- auc(roc_curve)
  cat("OvA AUC for class", levels(df.1$response_2019)[i], ":", class_auc[i], "\n")
}

print(class_auc)
```
### Model Exploration

### Check whether the demographic variables is predictive for income

```{r}
test8 <- subset(acl_new, response_2019 == "r")
```

```{r}
#check NA's
summary_stats <- lapply(test8, count_missing_categorical)
column_summary <- sapply(summary_stats, function(x) x)
print(column_summary)
```
```{r}
extract_obs <- test8[is.na(test8$AgeCat_2019), ]
print(extract_obs)
```
```{r}
# impute age_2019 from age_2011 --> because they are in the age 3 group, they must stay in age 3 group for 2019. 
test8$AgeCat_2019 <- ifelse(is.na(test8$AgeCat_2019), test8$AgeCat_2011, test8$AgeCat_2019)
```

```{r}
#check NA's
summary_stats <- lapply(test8, count_missing_categorical)
column_summary <- sapply(summary_stats, function(x) x)
print(column_summary)
```
### Model with income_2019 as an outcome and demographic variables as predictors. 

```{r}
fit.t8 <- lm(income_2019 ~ as.factor(sex_2019) + as.factor(race_cat) + as.factor(AgeCat_2019), data = test8)
summary(fit.t8)
```
Here sex and race are predictive for income_2019. 

### Model with log_income_2019 as an outcome and demographic variables as predictors. 

```{r}
fit.t9 <- lm(log_inc_2019 ~ as.factor(sex_2019) + as.factor(race_cat)+ as.factor(AgeCat_2019), data = test8)
summary(fit.t9)
```
Sex, race, age are significant for log income 2019. 

### Cube Income

```{r}
fit.t10 <- lm(cube_inc_2019 ~ as.factor(sex_2019) + as.factor(race_cat)+ as.factor(AgeCat_2019), data = test8)
summary(fit.t10)
```
sex, race, age are predictive for cube income 2019. 

### Using log income from previous years

```{r}
fit.t11 <- lm(log_inc_2019 ~ as.factor(sex_2019) + as.factor(race_cat) + as.factor(AgeCat_2019) + log_inc_2001 +log_inc_2011, data = test8)
summary(fit.t11)
```
Log income from 2001 and 2011 are predictive for log income 2019 in addition to the demographic variables. 

### Interaction of log

```{r}
fit.t12 <- lm(log_inc_2019 ~ as.factor(sex_2019) + as.factor(race_cat) + as.factor(AgeCat_2019) + log_inc_2001 * log_inc_2011, data = test8)
summary(fit.t12)
```
Interaction of log income 2001 and log income 2011 is not significant. 

### Growth

```{r}
fit.t13 <- lm(log_inc_2019 ~ as.factor(sex_2019) + as.factor(race_cat) + as.factor(AgeCat_2019) + growth, data = test8)
summary(fit.t13)
```
Growth is not significant for log income 2019. 

### Growth Quantiles

```{r}
fit.t14 <- lm(log_inc_2019 ~ as.factor(sex_2019) + as.factor(race_cat) + as.factor(AgeCat_2019) + as.factor(growth_quantiles), data = test8)
summary(fit.t14)
```
Growth quantile is not predictive for income_2019. 

### Interaction between log_income_2011 and growth_quantile

```{r}
fit.t15 <- lm(log_inc_2019 ~ as.factor(sex_2019) + as.factor(race_cat) + as.factor(AgeCat_2019) + log_inc_2011 * as.factor(growth_quantiles), data = test8)
summary(fit.t15)
```
Interaction between log_income_2011 and growth quantiles are not significant. 

Starting from here, use try to explore cube_income, growth, and growth quantiles one by one. 

### Model 2

Include std_log_2001

```{r}
#create model
df.2 <- acl_new
fit.2 <- multinom(response_2019 ~ TotInc_l_2001 + TotInc_l_2011 + TotInc_h_2001 + TotInc_h_2011 + std_log_2001 + std_log_2011 + sex_2001 + race_cat + AgeCat_2011 + division_2001 + division_2011 + weight_2001 + weight_2011 + proxy_2011, data = df.2)

#summary
summary(fit.2)

# Print the model summary
kable(tidy(fit.2))
```

The variables that are significant for nr : TotInc_l_20111, AgeCat_20112, AgeCat_20113, proxy_20111.  

The variables that are significant for d : 	sex_20012, AgeCat_20112, AgeCat_20113, proxy_20111. 

### Compute the predicted probability

```{r}
# predicted probability
pred_prob <- predict(fit.2, newdata = df.2, type = "probs")[,1]
df.2$pred_prob <- pred_prob
summary(df.2$pred_prob) #max stable
```
### Evaluate the model

```{r}
# Calculate OvA AUC for each class
class_auc <- numeric(length(levels(df.2$response_2019)))
for (i in seq_along(class_auc)) {
  true_labels <- as.numeric(df.2$response_2019 == levels(df.2$response_2019)[i])
  pred_scores <- pred_prob
  roc_curve <- roc(true_labels, pred_scores)
  class_auc[i] <- auc(roc_curve)
  cat("OvA AUC for class", levels(df.2$response_2019)[i], ":", class_auc[i], "\n")
}

print(class_auc) # AUC increase
```
### Model 3 - Cube Income

```{r}
#create model
df.3 <- acl_new
fit.3 <- multinom(response_2019 ~ TotInc_l_2001 + TotInc_l_2011 + TotInc_h_2001 + TotInc_h_2011 + cube_inc_2001 + cube_inc_2011 + sex_2001 + race_cat + AgeCat_2011 + division_2001 + division_2011 + weight_2001 + weight_2011 + proxy_2011, data = df.3)

#summary
summary(fit.3)

# Print the model summary
kable(tidy(fit.3))
```

The predictive variables for nr : TotInc_l_20111, AgeCat_20112, 	AgeCat_20113, proxy_20111.

The predictive variables for d : sex_20012, AgeCat_20112, AgeCat_20113, proxy_20111. 

### Compute the predicted probability

```{r}
# predicted probability
pred_prob <- predict(fit.3, newdata = df.3, type = "probs")[,1]
df.3$pred_prob <- pred_prob
summary(df.3$pred_prob)
```
Max increase 

### Evaluate the model

```{r}
# Calculate OvA AUC for each class
class_auc <- numeric(length(levels(df.3$response_2019)))
for (i in seq_along(class_auc)) {
  true_labels <- as.numeric(df.3$response_2019 == levels(df.3$response_2019)[i])
  pred_scores <- pred_prob
  roc_curve <- roc(true_labels, pred_scores)
  class_auc[i] <- auc(roc_curve)
  cat("OvA AUC for class", levels(df.3$response_2019)[i], ":", class_auc[i], "\n")
}

print(class_auc) #AUC increase
```

### Model 4 : interaction of log income 2011 and growth quantile

```{r}
#create model
df.4 <- acl_new
fit.4 <- multinom(response_2019 ~ TotInc_l_2001 + TotInc_l_2011 + TotInc_h_2001 + TotInc_h_2011 + log_inc_2001 + log_inc_2011 + growth_quantiles + log_inc_2001 * growth_quantiles + sex_2001 + race_cat + AgeCat_2011 + division_2001 + division_2011 + weight_2001 + weight_2011 + proxy_2011, data = df.4)

#summary
summary(fit.4)

# Print the model summary
kable(tidy(fit.4))
```

Interaction is not predictive

Predictive for nr : TotInc_l_20111, AgeCat_20112, AgeCat_20113, proxy_20111.  

Predictive for d : sex_20012, AgeCat_20112, AgeCat_20113, proxy_20111. 

### Compute the predicted probability

```{r}
# predicted probability
pred_prob <- predict(fit.4, newdata = df.4, type = "probs")[,1]
df.4$pred_prob <- pred_prob
summary(df.4$pred_prob)
```

### Evaluate the model

```{r}
# Calculate OvA AUC for each class
class_auc <- numeric(length(levels(df.4$response_2019)))
for (i in seq_along(class_auc)) {
  true_labels <- as.numeric(df.4$response_2019 == levels(df.4$response_2019)[i])
  pred_scores <- pred_prob
  roc_curve <- roc(true_labels, pred_scores)
  class_auc[i] <- auc(roc_curve)
  cat("OvA AUC for class", levels(df.4$response_2019)[i], ":", class_auc[i], "\n")
}

print(class_auc) #AUC increase
```

### Model 5 : interaction of std log income 2011 and growth quantile

```{r}
#create model
df.5 <- acl_new
fit.5 <- multinom(response_2019 ~ sex_2001 + race_cat + AgeCat_2011 + division_2001 + division_2011 + TotInc_l_2001 + TotInc_l_2011 + TotInc_h_2001 + TotInc_h_2011 + std_log_2001 + std_log_2011 + growth_quantiles + std_log_2001 * growth_quantiles + weight_2001 + weight_2011 + proxy_2011, data = df.5)
                    
#summary
summary(fit.5)

# Print the model summary
kable(tidy(fit.5))
```

Interaction is not predictive

Predictive for nr : TotInc_l_20111, AgeCat_20112, AgeCat_20113, proxy_20111. 

Predictive for d : 	growth_quantiles2, growth_quantiles3, sex_20012, AgeCat_20114, AgeCat_20112, AgeCat_20113, proxy_20111.

### Weighted Regression

```{r}
df.5.design <- svydesign(data = df.5,
                            id = ~1,
                            weights = ~weight_2011)
```


```{r}
library(svyVGAM)
weighted.fit5 <- svy_vglm(response_2019 ~ sex_2001 + race_cat + AgeCat_2011 + division_2001 + division_2011 + TotInc_l_2001 +
                       TotInc_l_2011 + TotInc_h_2001 + TotInc_h_2011 + std_log_2001 + std_log_2011 + growth_quantiles +
                       std_log_2001 * growth_quantiles + weight_2001 + weight_2011 + proxy_2011,
                       family=multinomial(refLevel="r"), design=df.5.design)
summary(weighted.fit5)
```

```{r}
#predict(weighted.fit5, data=df.5)
```

### Model 6 : interaction of age and proxy

```{r}
#create model
df.6 <- acl_new
fit.6 <- multinom(response_2019 ~ sex_2001 + race_cat + AgeCat_2011 + division_2001 + division_2011 + TotInc_l_2001 + TotInc_l_2011 + TotInc_h_2001 + TotInc_h_2011 + std_log_2001 + std_log_2011 + growth_quantiles + weight_2001 + weight_2011 + proxy_2011 + AgeCat_2011 * proxy_2011 , data = df.6)
                    
#summary
summary(fit.6)

# Print the model summary
kable(tidy(fit.6))
```

### Compute the predicted probability

```{r}
# predicted probability
pred_prob <- predict(fit.6, newdata = df.6, type = "probs")[,1]
df.6$pred_prob <- pred_prob
summary(df.6$pred_prob)
```
### Evaluate the model

```{r}
# Calculate OvA AUC for each class
class_auc <- numeric(length(levels(df.6$response_2019)))
for (i in seq_along(class_auc)) {
  true_labels <- as.numeric(df.6$response_2019 == levels(df.6$response_2019)[i])
  pred_scores <- pred_prob
  roc_curve <- roc(true_labels, pred_scores)
  class_auc[i] <- auc(roc_curve)
  cat("OvA AUC for class", levels(df.6$response_2019)[i], ":", class_auc[i], "\n")
}

print(class_auc) #AUC increase
```

### Weighting process 

Before going to this part, make sure you choose the best model. The best model is fit.6. 

### Compute predicted probability and weight based on model

```{r}
df.6$nr_weight <- 1/df.6$pred_prob
summary(df.6$pred_prob)
summary(df.6$nr_weight)
```

The maximum value of predicted response is 0.9591 which is still reasonable predicted value. 

### Who is the person with the highest response propensity?

```{r}
# Extract observations with Value above the threshold
sel_obs <- subset(df.6, pred_prob > 0.95)

# Print the selected observations
print(sel_obs)
```

People who is always respond tend to have this characteristics : female, other race, age >=55 years old, the growth of income is on the first quantile. 

### Compute attrition weight based on non response weight 2019 * selection weight in a year of 2011

```{r}
df.6$attr_weight <- df.6$nr_weight * df.6$weight_2011
```

```{r}
summary(df.6$attr_weight)
sd(df.6$attr_weight)#Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 0.1271  0.9830  1.7249  2.3414  2.5234 87.3953 
```

```{r}
#summary((df.5$weight_2019))
```

```{r}
# summary((df.5$weight_2019))
# sd_w2019 <- sd(df.5$weight_2019, na.rm = TRUE)
# sd_w2019
# mean_w2019 <- mean(df.5$weight_2019, na.rm = TRUE)
# mean_w2019
# cv = sd_w2019^2/mean_w2019
# cv
```

```{r}
#h1 <- hist(df.5$weight_2019)
h2 <- hist(df.6$nr_weight)
h3 <- hist(df.6$attr_weight)

ggarrange(h2, h3, ncol = 3, nrow = 1)
```
### Prepare ACL data for estimation for household level

```{r}
# Add age column to df.g
df.6.est <- merge(df.6, acl_sub3[, c("V2", "age_2011", "age_2019")], by = "V2", all.x = TRUE)
```

```{r}
#subset the data only for those who response
df.6.estnew <- df.6.est[df.6.est$response_2019 == "r", ]
dim(df.6.estnew)
```

```{r}
# recode other to non black
# df.5.est <- df.5.est %>%
#   mutate(recoded_race = ifelse(race_cat == 3, 1, race_cat))
```

```{r}
dim(df.6.est)
```
```{r}
table(df.6.estnew$sex_2019)
table(df.6.estnew$race_cat)
table(df.6.estnew$AgeCat_2019)
```
```{r}
#ext6 <- df.5.estnew[is.na(df.5.estnew$age_2019),]
```

```{r}
#ext6 <- subset(acl_data, V2=="10503011" | V2=="390804511" | V2=="485129911")
#ext7 <- ext6[,c("V2","V22009", "V15101", "V15102", "V20101", "V20102")]
```

```{r}
#impute age 2019 from age_2011 (3 observation)
df.6.estnew$age_2019 <- ifelse(is.na(df.6.estnew$age_2019), df.6.estnew$age_2011 + 8, df.6.estnew$age_2019)
```

```{r}
df.6.estnew <- df.6.estnew %>%
  mutate(age_cat_new = case_when(
    age_2019 >= 45 & age_2019 <= 64 ~ "1",
    age_2019 >= 65 & age_2019 <= 79 ~ "2",
    age_2019 >= 80 ~ "3"
  ))
```


```{r}
summary(df.6.estnew$age_2019)
```
### Prepare CPS data

```{r}
cps2019 <- read.csv("O:/ACL Data Management/wave6/_acl123456_newest/_to outside teams/_aulia thesis/cps2019.csv")
```

```{r}
table(cps2019$a_sex)
table(cps2019$prdtrace)
summary(cps2019$a_age)
```
```{r}
#subset data only for age >= 58 yo. 
cps2019new <- cps2019 %>% filter(a_age >= 58 & a_age <= 99)
dim(cps2019new)
```

```{r}
#Recode the sex
cps2019new <- cps2019new %>%
  mutate(sex_cat = case_when(
    a_sex == "1" ~ "1",
    a_sex == "2" ~ "2",
  ))

#Recode the age
cps2019new <- cps2019new %>%
  mutate(age_cat = case_when(
    a_age >= 45 & a_age <= 64 ~ "1",
    a_age >= 65 & a_age <= 79 ~ "2",
    a_age >= 80 ~ "3"
    
  ))

#Recode the race
cps2019new <- cps2019new %>%
  mutate(race_cat = ifelse(prdtrace != 2, 1, prdtrace))
```

```{r}
cps2019new$race_cat <- as.factor(cps2019new$race_cat)
```

```{r}
table(cps2019new$race_cat)
```
### CPS weighted estimates

```{r}
#create table for sex 
cps2019_sex_new <- cps2019new %>% 
  group_by(a_sex) %>% 
  summarise(pop = sum(marsupwt)) %>% 
  mutate(pct = pop/sum(pop))
cps2019_sex_new
```

```{r}
cps2019_age_new <- cps2019new %>% 
  group_by(age_cat) %>% 
  summarise(pop=sum(marsupwt)) %>% 
  mutate(pct = pop/sum(pop))
cps2019_age_new
```

```{r}
cps2019_race_new <- cps2019new %>% 
  group_by(race_cat) %>% 
  summarise(pop=sum(marsupwt)) %>% 
  mutate(pct = pop/sum(pop))
cps2019_race_new
```

### Start comparison

### Sex

```{r}
theme_set(theme_pubr())

## CPS 
colnames(cps2019_sex_new) <- c("sex","pop","per")
plot1 <- ggplot(cps2019_sex_new, aes(x=factor(sex), y=per)) +
  geom_bar(stat="identity") +
  scale_y_continuous(labels=scales::percent,limits=c(0,0.75)) +
  geom_text(aes(label= scales::percent(per), y=per),stat="identity", vjust=-0.35, color="black", size=4) + 
  labs(title="US Sex Distribution, 2019",x="Sex",y="Perc")

## ACL
# Remove duplicate columns from df.g
df.6.estnew <- df.6.estnew[, !duplicated(colnames(df.6.estnew))]

# Generate the plot
plot2 <- ggplot(df.6.estnew, aes(x = factor(sex_2001), weight = attr_weight)) +
  geom_bar(aes(y = after_stat(count / sum(count)))) +
  geom_text(aes(label = scales::percent(after_stat(count / sum(count))),
                y = after_stat(count / sum(count))), stat = "count", vjust = -0.35, color = "black", size = 4) +
  scale_y_continuous(labels = scales::percent, limits = c(0, 0.75)) +
  labs(title = "Weighted Sex, 2019", x = "Sex", y = "Perc") 

## un-weighted sample sex
plot3 <- ggplot(df.6.estnew, aes(x = factor(sex_2001))) +
  geom_bar(aes(y = after_stat(count / sum(count)))) +
  geom_text(aes(label = scales::percent(after_stat(count / sum(count))),
                y = after_stat(count / sum(count))), stat = "count", vjust = -0.35, color = "black", size = 4) +
  scale_y_continuous(labels = scales::percent, limits = c(0, 0.75)) +
  labs(title = "Unweighted Sex, 2019", x = "Sex", y = "Perc") 

ggarrange(plot2,plot3,plot1, ncol = 1, nrow = 3)
```
### Race

Race: 1=Non Black 2=Black

```{r}
theme_set(theme_pubr())

## US race
colnames(cps2019_race_new) <- c("race","pop","per")
plot7 <- ggplot(cps2019_race_new, aes(x=factor(race), y=per)) +
  geom_bar(stat="identity") +
  scale_y_continuous(labels=scales::percent,limits=c(0,0.95)) +
  geom_text(aes(label= scales::percent(per), y=per),stat="identity", vjust=-0.35, color="black", size=4) + 
  labs(title="US Race Distribution, 2019",x="Race",y="Perc")

## weighted sample sex
# Remove duplicate columns from df.g
df.6.estnew <- df.6.estnew[, !duplicated(colnames(df.6.estnew))]
# Generate the plot
plot8 <- ggplot(df.6.estnew, aes(x = factor(race_cat), weight = attr_weight)) +
  geom_bar(aes(y = after_stat(count / sum(count)))) +
  geom_text(aes(label = scales::percent(after_stat(count / sum(count))),
                y = after_stat(count / sum(count))), stat = "count", vjust = -0.35, color = "black", size = 4) +
  scale_y_continuous(labels = scales::percent, limits = c(0, 0.95)) +
  labs(title = "Weighted Race, 2019", x = "Race", y = "Perc") 

## un-weighted sample sex
plot9 <- ggplot(df.6.estnew, aes(x = factor(race_cat))) +
  geom_bar(aes(y = after_stat(count / sum(count)))) +
  geom_text(aes(label = scales::percent(after_stat(count / sum(count))),
                y = after_stat(count / sum(count))), stat = "count", vjust = -0.35, color = "black", size = 4) +
  scale_y_continuous(labels = scales::percent, limits = c(0, 0.95)) +
  labs(title = "Unweighted Race, 2019", x = "Race", y = "Perc") 

ggarrange(plot8,plot9,plot7, ncol = 1, nrow = 3)
```
### Age

```{r}
theme_set(theme_pubr())

## US age
colnames(cps2019_age_new) <- c("age","pop","per")
plot10 <- ggplot(cps2019_age_new, aes(x=factor(age), y=per)) +
  geom_bar(stat="identity") +
  scale_y_continuous(labels=scales::percent,limits=c(0,0.95)) +
  geom_text(aes(label= scales::percent(per), y=per),stat="identity", vjust=-0.35, color="black", size=4) + 
  labs(title="US Age Distribution, 2019",x="Age",y="Perc")

## weighted sample sex
# Remove duplicate columns from df.g
df.6.estnew <- df.6.estnew[, !duplicated(colnames(df.6.estnew))]
# Generate the plot
plot11 <- ggplot(df.6.estnew, aes(x = factor(age_cat_new), weight = attr_weight)) +
  geom_bar(aes(y = after_stat(count / sum(count)))) +
  geom_text(aes(label = scales::percent(after_stat(count / sum(count))),
                y = after_stat(count / sum(count))), stat = "count", vjust = -0.35, color = "black", size = 4) +
  scale_y_continuous(labels = scales::percent, limits = c(0, 0.95)) +
  labs(title = "Weighted Age, 2019", x = "Age", y = "Perc") 

## un-weighted sample sex
plot12 <- ggplot(df.6.estnew, aes(x = factor(age_cat_new))) +
  geom_bar(aes(y = after_stat(count / sum(count)))) +
  geom_text(aes(label = scales::percent(after_stat(count / sum(count))),
                y = after_stat(count / sum(count))), stat = "count", vjust = -0.35, color = "black", size = 4) +
  scale_y_continuous(labels = scales::percent, limits = c(0, 0.95)) +
  labs(title = "Unweighted Age, 2019", x = "Age", y = "Perc") 

ggarrange(plot11,plot12,plot10, ncol = 1, nrow = 3)
```

### Code Archive

### Age 

```{r}
### unweighted ACL
#summary(df.5.estnew$age_2019)
```
```{r}
# weighted ACL 
# set the survey design
#acl_design <- svydesign(data = df.5.estnew,
#                            id = ~1,
#                            weights = ~attr_weight)
```

```{r}
#mean
#svymean(~age_2019, design = acl_design)
```
```{r}
#median
#svyquantile(~age_2019, acl_design, quantiles = 0.5)
```
```{r}
#weighted CPS
#cps_design <- svydesign(ids = ~1, weights = ~marsupwt, data = cps2019new)
```

```{r}
#mean
#svymean(~a_age, design = cps_design)
```
```{r}
#median
#svyquantile(~a_age, cps_design, quantiles = 0.5)
```
### Check ACL Baseline

```{r}
#acl_1986 <- acl_data[, c("V103", "V2004", "V104", "V1856")]
```

```{r}
#acl_1986$V103 <- as.character(acl_1986$V103)
#acl_1986$V2004 <- as.character(acl_1986$V2004)
```

```{r}
#acl1986.design <- svydesign(data = acl_1986,
#                            id = ~1,
#                            weights = ~V1856)
```

```{r}
#svymean(~V103, design=acl1986.design)
```
```{r}
#svymean(~V2004, design=acl1986.design) #black=2
```
```{r}
#svymean(~V104, design=acl1986.design)
#summary(acl_1986$V104)
```
```{r}
#cps1986 <- readLines("O:/ACL Data Management/wave6/_acl123456_newest/_to outside teams/_aulia thesis/ICPSR_04376-V1/ICPSR_04376/DS0001.txt", encoding = "latin1")
```

### Check CPS

### Prepare CPS estimation

```{r}
# library(cpsR)
# 
# # Set your Census Bureau API key
# census_api_key <- "995d35eb9bf08b97abf94f20f8ef5fb0aacba624"
# 
# # Run the code
# asec2019 <- get_asec(2019,vars = c("A_SEX","A_AGE","AGE1","PRDTRACE", "A_FNLWGT", "MARSUPWT"), key = census_api_key)
```

```{r}
# cpsnew_2019 <- get_basic(2019, 
#                          12, 
#                          vars = c("a_sex", "prpertyp", "prtage", "pemlr"), 
#                          key = census_api_key, 
#                          show_url = FALSE, 
#                          tibble = TRUE, 
#                          convert = TRUE
#                          )
```

### Check ACS

```{r}
# View(load_variables(2019, "acs5", cache=TRUE))
```

```{r}
# acs_2019 <- get_pums(variables=c("SEX", "AGEP", "RAC1P", "WGTP1"), 
#                      year=2019, 
#                      state = "all")
```

### Prepare ACL estimation

```{r}
# open ACL individual data
# acl2019 <- read.csv("O:/ACL Data Management/wave6/_acl123456_newest/_to outside teams/_aulia thesis/acl2019.csv")
```

```{r}
# remove income information
# acl_ind <- acl2019[,-c(7:10)]
```

```{r}
# join the data with the response indicator
# acl_ind <- left_join(acl_ind, select(acl_sub2, V1, race_1968, response_2001, response_2011, response_2019), by = "V1")
# dim(acl_ind) #141063     10
```

```{r}
#subset data only for those who response in 2001 and 2011
# acl_ind2 <- acl_ind[acl_ind$response_2001=="r" & acl_ind$response_2011=="r",] 
# dim(acl_ind2) #46059    10
```

```{r}
#change missing value into NA
# acl_ind2 <- replace(acl_ind2, acl_ind2 == -6 | acl_ind2 == -95.0000000 | acl_ind2 == -96.0000000 | acl_ind2 == -98.0000000 | acl_ind2 == -99.0000000, NA)
```

```{r}
#remove the missing value, the missing value is not important since it is caused by the extra rows in the data entry process
# acl_ind3 <- acl_ind2[complete.cases(acl_ind2$sex2019, acl_ind2$age2019, acl_ind2$race_1968), ]
# dim(acl_ind3)
```

```{r}
# table(acl_ind3$sex2019)
# table(acl_ind3$age2019)
# table(acl_ind3$race_1968)
```

### Categorize age, sex, age in ACL individual

```{r}
#create factor for sex
# acl_ind3$sex2019 <- factor(acl_ind3$sex2019, levels=c("1","2"))
# acl_ind3$sex2019 <- relevel(acl_ind3$sex2019, ref="1") 
```

```{r}
#create factor for race
# acl_ind3 <- acl_ind3 %>%
#   mutate(race1968_cat = case_when(
#     race_1968 == 1 ~ 1,
#     race_1968 == 2 ~ 2,
#     race_1968 %in% c(3, 4, 5) ~ 3
#   ))
# 
# acl_ind3$race1968_cat <- factor(acl_ind3$race1968_cat, levels=c("1","2", "3"))
# acl_ind3$race1968_cat <- relevel(acl_ind3$race1968_cat, ref="1") 
```

```{r}
#create factor for age
# acl_ind3 <- acl_ind3 %>%
#   mutate(age2019_cat = case_when(
#     age2019 >= 0 & age2019 <= 29 ~ 1,
#     age2019 >= 30 & age2019 <= 54 ~ 2,
#     age2019 >= 55 ~ 3
#   ))
# 
# acl_ind3$age2019_cat <- factor(acl_ind3$age2019_cat, levels=c("1","2","3"))
# acl_ind3$age2019_cat <- relevel(acl_ind3$age2019_cat, ref="1") 
```

```{r}
# table(acl_ind3$sex2019)
# table(acl_ind3$race1968_cat)
# table(acl_ind3$age2019_cat)
```

### Remove ACL who has empty sex, race and age in 2019

```{r}
# acl_ind4 <- left_join(acl_ind3, select(df.5, V1, attr_weight), by = "V1")
```

```{r}
#subset datasets just for response 
# df.5.est <- df.5[df.5$response_2019 == "r" &
#                             !is.na(df.5$AgeCat_19) & df.5$AgeCat_19 != "" &
#                             !is.na(df.5$race_cat) & df.5$race_cat != "", ]
```


### Prepare CPS estimation

```{r}
#library(cpsR)

# Set your Census Bureau API key
#census_api_key <- "995d35eb9bf08b97abf94f20f8ef5fb0aacba624"

# Run the code
#asec2019 <- get_asec(2019,vars = c("A_SEX","A_AGE","AGE1","PRDTRACE", "A_FNLWGT", "MARSUPWT"), key = census_api_key)
```

```{r}
#head(asec2019)
```

```{r}
#dim(asec2019)
```

```{r}
#cps2019 <- as.data.frame(asec2019)
```

```{r}
# save cps data
#write.csv(cps2019, file = "O:/ACL Data Management/wave6/_acl123456_newest/_to outside teams/_aulia thesis/cps2019.csv", row.names = FALSE)
```

```{r}
# cps2019 <- read.csv("O:/ACL Data Management/wave6/_acl123456_newest/_to outside teams/_aulia thesis/cps2019.csv")
```

### Recode sex, age, race for CPS

Sex : 1=Male, 2=Female

Age: 1=0-29 2=30-54 3=55+

Race: 1=White 2=Black 3=Other

```{r}
#Recode the sex
# cps2019 <- cps2019 %>%
#   mutate(sex_cat = case_when(
#     a_sex == "1" ~ "1",
#     a_sex == "2" ~ "2",
#   ))
# 
# #Recode the age
# cps2019 <- cps2019 %>%
#   mutate(age_cat = case_when(
#     age1 >= 0 & age1 <= 6 ~ "1",
#     age1 >= 7 & age1 <= 11 ~ "2",
#     age1 >= 12 ~ "3"
#   ))
# 
# #Recode the race
# cps2019 <- cps2019 %>%
#   mutate(race_cat = case_when(
#     prdtrace == 1 ~ "1",
#     prdtrace == 2 ~ "2",
#     between(prdtrace, 3, 26) ~ "3",
#     TRUE ~ as.character(prdtrace) 
#   ))
```

### CPS weighted estimates

```{r}
#create table for sex 
# cps2019_sex <- cps2019 %>% 
#   group_by(sex_cat) %>% 
#   summarise(pop = sum(marsupwt)) %>% 
#   mutate(pre = pop/sum(pop))
# cps2019_sex
```

```{r}
# cps2019_age <- cps2019 %>% 
#   group_by(age_cat) %>% 
#   summarise(pop=sum(marsupwt)) %>% 
#   mutate(pre = pop/sum(pop))
# cps2019_age
```

```{r}
# cps2019_race <- cps2019 %>% 
#   group_by(race_cat) %>% 
#   summarise(pop=sum(marsupwt)) %>% 
#   mutate(pre = pop/sum(pop))
# cps2019_race
```


### Compare ACL to CPS

### sex (1=male, 2=female)

```{r}
# theme_set(theme_pubr())
# 
# ## CPS 
# colnames(cps2019_sex) <- c("sex","pop","per")
# plot1 <- ggplot(cps2019_sex, aes(x=factor(sex), y=per)) +
#   geom_bar(stat="identity") +
#   scale_y_continuous(labels=scales::percent,limits=c(0,0.75)) +
#   geom_text(aes(label= scales::percent(per), y=per),stat="identity", vjust=-0.35, color="black", size=4) + 
#   labs(title="US Sex Distribution, 2019",x="Sex",y="Perc")
# 
# ## ACL
# # Remove duplicate columns from df.g
# acl_ind4 <- acl_ind4[, !duplicated(colnames(acl_ind4))]
# 
# # Generate the plot
# plot2 <- ggplot(acl_ind4, aes(x = factor(sex2019), weight = attr_weight)) +
#   geom_bar(aes(y = after_stat(count / sum(count)))) +
#   geom_text(aes(label = scales::percent(after_stat(count / sum(count))),
#                 y = after_stat(count / sum(count))), stat = "count", vjust = -0.35, color = "black", size = 4) +
#   scale_y_continuous(labels = scales::percent, limits = c(0, 0.75)) +
#   labs(title = "Weighted Sex, 2019", x = "Sex", y = "Perc") 
# 
# ## un-weighted sample sex
# plot3 <- ggplot(acl_ind4, aes(x = factor(sex2019))) +
#   geom_bar(aes(y = after_stat(count / sum(count)))) +
#   geom_text(aes(label = scales::percent(after_stat(count / sum(count))),
#                 y = after_stat(count / sum(count))), stat = "count", vjust = -0.35, color = "black", size = 4) +
#   scale_y_continuous(labels = scales::percent, limits = c(0, 0.75)) +
#   labs(title = "Unweighted Sex, 2019", x = "Sex", y = "Perc") 
# 
# ggarrange(plot2,plot3,plot1, ncol = 1, nrow = 3)
```
The estimation on weighted ACL makes the number closer to the CPS estimates. Therefore, the attrition weights for ACL works well. 

### Age

```{r}
#acl_age_w <- df.1.est %>% 
 # group_by(AgeCat_19) %>% 
 # summarise(pop=sum(attr_weight)) %>% 
# mutate(pre = pop/sum(pop))
#acl_age_w
```

All household has age > 55 years old. What should I do?

```{r}
# theme_set(theme_pubr())
# 
# ## US age 
# colnames(cps2019_age) <- c("age","pop","per")
# plot4 <- ggplot(cps2019_age, aes(x=factor(age), y=per)) +
#   geom_bar(stat="identity") +
#   scale_y_continuous(labels=scales::percent,limits=c(0,0.75)) +
#   geom_text(aes(label= scales::percent(per), y=per),stat="identity", vjust=-0.35, color="black", size=4) + 
#   labs(title="US Age Distribution, 2019",x="Age",y="Perc")
# 
# ## weighted sample age
# # Remove duplicate columns from df.g
# acl_ind4 <- acl_ind4[, !duplicated(colnames(acl_ind4))]
# # Generate the plot
# plot5 <- ggplot(acl_ind4, aes(x = age2019_cat, weight = attr_weight)) +
#   geom_bar(aes(y = after_stat(count / sum(count)))) +
#   geom_text(aes(label = scales::percent(after_stat(count / sum(count))),
#                 y = after_stat(count / sum(count))), stat = "count", vjust = -0.35, color = "black", size = 4) +
#   scale_y_continuous(labels = scales::percent, limits = c(0, 0.9999)) +
#   labs(title = "Weighted Age, 2019", x = "Age", y = "Perc") 
# 
# ## un-weighted sample age
# plot6 <- ggplot(acl_ind4, aes(x = age2019_cat)) +
#   geom_bar(aes(y = after_stat(count / sum(count)))) +
#   geom_text(aes(label = scales::percent(after_stat(count / sum(count))),
#                 y = after_stat(count / sum(count))), stat = "count", vjust = -0.35, color = "black", size = 4) +
#   scale_y_continuous(labels = scales::percent, limits = c(0, 0.9999)) +
#   labs(title = "Unweighted Age, 2019", x = "Age", y = "Perc") 
# 
# ggarrange(plot5,plot6,plot4, ncol = 1, nrow = 3)
```
### Race

Race: 1=White 2=Black 3=Other

```{r}
# theme_set(theme_pubr())
# 
# ## US age 
# colnames(cps2019_race) <- c("race","pop","per")
# plot7 <- ggplot(cps2019_race, aes(x=factor(race), y=per)) +
#   geom_bar(stat="identity") +
#   scale_y_continuous(labels=scales::percent,limits=c(0,0.85)) +
#   geom_text(aes(label= scales::percent(per), y=per),stat="identity", vjust=-0.35, color="black", size=4) + 
#   labs(title="US Race Distribution, 2019",x="Race",y="Perc")
# 
# ## weighted sample sex
# # Remove duplicate columns from df.g
# #race1968_cat <- race1968_cat[, !duplicated(colnames(race1968_cat))]
# # Generate the plot
# plot8 <- ggplot(acl_ind4, aes(x = race1968_cat, weight = attr_weight)) +
#   geom_bar(aes(y = after_stat(count / sum(count)))) +
#   geom_text(aes(label = scales::percent(after_stat(count / sum(count))),
#                 y = after_stat(count / sum(count))), stat = "count", vjust = -0.35, color = "black", size = 4) +
#   scale_y_continuous(labels = scales::percent, limits = c(0, 0.95)) +
#   labs(title = "Weighted Race, 2019", x = "Race", y = "Perc") 
# 
# ## un-weighted sample sex
# plot9 <- ggplot(acl_ind4, aes(x = race1968_cat)) +
#   geom_bar(aes(y = after_stat(count / sum(count)))) +
#   geom_text(aes(label = scales::percent(after_stat(count / sum(count))),
#                 y = after_stat(count / sum(count))), stat = "count", vjust = -0.35, color = "black", size = 4) +
#   scale_y_continuous(labels = scales::percent, limits = c(0, 0.95)) +
#   labs(title = "Unweighted Race, 2019", x = "Race", y = "Perc") 
# 
# ggarrange(plot8,plot9,plot7, ncol = 1, nrow = 3)
```
The attrition weight works for black and other race, but not for white. 
Sample weighted - White is 87.4%, Sample unweighted - White is 76%, CPS white is 76.5%

### Calibration

### Prepare ACL Data

```{r}
#set the survey design
#acl_design <- svydesign(data = acl_ind4,
                            #id = ~1,
                            #weights = ~attr_weight)
```

```{r}
# estimate sex
# svytotal(~sex2019, design = acl_design)
```
```{r}
# svytotal(~age2019_cat, design = acl_design)
```

```{r}
# svytotal(~race1968_cat, design = acl_design)
```
```{r}
# svymean(~sex2019, design = acl_design)
```
```{r}
# svymean(~age2019_cat, design = acl_design)
```
```{r}
# svymean(~race1968_cat, design = acl_design)
```

### Prepare CPS data

```{r}
# cps_design <- svydesign(ids = ~1, weights = ~marsupwt, data = cps2019)
```

```{r}
# svytotal(c(rep(1, nrow(cps2019))), cps_design)
```
```{r}
# svytotal(~sex_cat, design = cps_design)
```
```{r}
# svytotal(~age_cat, design = cps_design)
```
```{r}
# svytotal(~race_cat, design = cps_design)
```
```{r}
# svymean(~as.factor(sex_cat), design = cps_design)
```
```{r}
# svymean(~as.factor(age_cat), design = cps_design)
```
```{r}
# svymean(~as.factor(race_cat), design = cps_design)
```
### Raking

```{r}
# reformat the CPS data for raking
# pop.sex <- data.frame(sex=c("1","2"), Freq=c(159027796, 165328045))
# pop.age <- data.frame(age_cat=c("1","2","3"), Freq=c(126154080, 103658462, 94543300))
# pop.race <- data.frame(race_cat=c("1","2","3"), Freq=c(248000958, 42841641, 33513242))
```

```{r}
#do raking
#raked_design <- rake(acl_design,
#                     sample.margins = list(~sex2019,~age2019_cat,~race1968_cat),
#                     population.margins = list(pop.sex, pop.age, pop.race))
```

```{r}
# svytotal(~sex2019, acl_design)
# svytotal(~age2019_cat, acl_design)
# svytotal(~race1968_cat, acl_design)
```

```{r}
# str(acl_ind4$sex2019)
# str(acl_ind4$age2019_cat)
# str(acl_ind4$race1968_cat)
```

```{r}
# str(pop.sex)
# str(pop.age)
# str(pop.race)
```

### Comparison with ACL 2011

```{r}
# acl2011 <- read.csv("O:/ACL Data Management/wave6/_acl123456_newest/_to outside teams/_aulia thesis/acl2011.csv")
```

```{r}
# subset only for response
# acl2011_sub <- acl2011[acl2011$response2011=="r",] 
```

```{r}
#change missing value into NA
# acl2011_sub <- replace(acl2011_sub, acl2011_sub == -6 | acl2011_sub == -94.0000000| acl2011_sub == -95.0000000 | acl2011_sub == -96.0000000 | acl2011_sub == -98.0000000 | acl2011_sub == -99.0000000, NA)
```

```{r}
#remove the missing value, the missing value is not important since it is caused by the extra rows in the data entry process
# acl2011_sub <- acl2011_sub[complete.cases(acl2011_sub$sex2011, acl2011_sub$age2011, acl2011_sub$race1968), ]
# dim(acl2011_sub)
```

```{r}
# table(acl2011_sub$sex2011)
# table(acl2011_sub$age2011)
# table(acl2011_sub$race1968)
```

### Categorize age and sex

```{r}
#Recode the sex
# acl2011_sub <- acl2011_sub %>%
#   mutate(sex_cat = case_when(
#     sex2011 == "1" ~ "1",
#     sex2011 == "2" ~ "2",
#   ))
# 
# #Recode the age
# acl2011_sub <- acl2011_sub %>%
#   mutate(age_cat = case_when(
#     age2011 >= 0 & age2011 <= 6 ~ "1",
#     age2011 >= 7 & age2011 <= 11 ~ "2",
#     age2011 >= 12 ~ "3"
#   ))
# 
# #Recode the race
# acl2011_sub <- acl2011_sub %>%
#   mutate(race_cat = case_when(
#     race1968 == 1 ~ "1",
#     race1968 == 2 ~ "2",
#     race1968 %in% c(3, 4, 5) ~ "3",
#     TRUE ~ as.character(race1968)
#   ))
```


### Estimate sex

```{r}
# Remove duplicate columns from df.g
# acl2011_sub <- acl2011_sub[, !duplicated(colnames(acl2011_sub))]
# # Generate the plot
# plot11_s <- ggplot(acl2011_sub, aes(x = sex_cat, weight = weight_2011)) +
#   geom_bar(aes(y = after_stat(count / sum(count)))) +
#   geom_text(aes(label = scales::percent(after_stat(count / sum(count))),
#                 y = after_stat(count / sum(count))), stat = "count", vjust = -0.35, color = "black", size = 4) +
#   scale_y_continuous(labels = scales::percent, limits = c(0, 0.9999)) +
#   labs(title = "Weighted Sex, 2011", x = "Age", y = "Perc") 
# 
# # Generate the plot
# plot19_s <- ggplot(acl_ind4, aes(x = sex2019, weight = attr_weight)) +
#   geom_bar(aes(y = after_stat(count / sum(count)))) +
#   geom_text(aes(label = scales::percent(after_stat(count / sum(count))),
#                 y = after_stat(count / sum(count))), stat = "count", vjust = -0.35, color = "black", size = 4) +
#   scale_y_continuous(labels = scales::percent, limits = c(0, 0.95)) +
#   labs(title = "Weighted Sex, 2019", x = "Race", y = "Perc") 
# 
# 
# ggarrange(plot11_s,plot19_s, ncol = 1, nrow = 2)
```
### Estimate race

```{r}
# Remove duplicate columns from df.g
# acl2011_sub <- acl2011_sub[, !duplicated(colnames(acl2011_sub))]
# # Generate the plot
# plot11_r <- ggplot(acl2011_sub, aes(x = race_cat, weight = weight_2011)) +
#   geom_bar(aes(y = after_stat(count / sum(count)))) +
#   geom_text(aes(label = scales::percent(after_stat(count / sum(count))),
#                 y = after_stat(count / sum(count))), stat = "count", vjust = -0.35, color = "black", size = 4) +
#   scale_y_continuous(labels = scales::percent, limits = c(0, 0.9999)) +
#   labs(title = "Weighted Race, 2011", x = "Age", y = "Perc") 
# 
# # Generate the plot
# plot19_r <- ggplot(acl_ind4, aes(x = race1968_cat, weight = attr_weight)) +
#   geom_bar(aes(y = after_stat(count / sum(count)))) +
#   geom_text(aes(label = scales::percent(after_stat(count / sum(count))),
#                 y = after_stat(count / sum(count))), stat = "count", vjust = -0.35, color = "black", size = 4) +
#   scale_y_continuous(labels = scales::percent, limits = c(0, 0.95)) +
#   labs(title = "Weighted Race, 2019", x = "Race", y = "Perc") 
# 
# 
# ggarrange(plot11_r,plot19_r, ncol = 1, nrow = 2)
```
### Estimate age

```{r}
# Remove duplicate columns from df.g
# acl2011_sub <- acl2011_sub[, !duplicated(colnames(acl2011_sub))]
# # Generate the plot
# plot11_a <- ggplot(acl2011_sub, aes(x = age_cat, weight = weight_2011)) +
#   geom_bar(aes(y = after_stat(count / sum(count)))) +
#   geom_text(aes(label = scales::percent(after_stat(count / sum(count))),
#                 y = after_stat(count / sum(count))), stat = "count", vjust = -0.35, color = "black", size = 4) +
#   scale_y_continuous(labels = scales::percent, limits = c(0, 0.9999)) +
#   labs(title = "Weighted Age, 2011", x = "Age", y = "Perc") 
# 
# # Generate the plot
# plot19_a <- ggplot(acl_ind4, aes(x = age2019_cat, weight = attr_weight)) +
#   geom_bar(aes(y = after_stat(count / sum(count)))) +
#   geom_text(aes(label = scales::percent(after_stat(count / sum(count))),
#                 y = after_stat(count / sum(count))), stat = "count", vjust = -0.35, color = "black", size = 4) +
#   scale_y_continuous(labels = scales::percent, limits = c(0, 0.95)) +
#   labs(title = "Weighted Age, 2019", x = "Race", y = "Perc") 
# 
# 
# ggarrange(plot11_a,plot19_a, ncol = 1, nrow = 2)
```



### Next step 

Feb 21

1. Transformation of log income (OK)

2. Modelling (OK)

3. Weighting (OK)

Feb 22

1. Model exploration

2. Calibration

3. Think about the age

4. Write the steps. 

Feb 23

1. Handling missing region --> check previous wave (OK)

2. Model exploration

3. Subset data 2019 to individual level (OK)

Feb 24

1. Check documentation rake 

2. Model exploration

3. Think about the estimation of age and race

Feb 25

1. Learn AUC and ROC --> R package

Questions

1. If I work with HH data, I only have respondent aged >=55 in wave 6. It means that the model is only covers senior people only. 

Feb 29

1. Re compute ACL 2011 weighted

2. Compute Weight distribution

March 23

1. Create descriptive statistics

2. Line chart

To do :

1. Recategorize age

2. check ACS

3. modelling check 

4. attrition rate using table


